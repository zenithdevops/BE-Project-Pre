{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _stylesheet = require(\"@react-pdf/stylesheet\");\n\nvar _layoutText = _interopRequireDefault(require(\"../svg/layoutText\"));\n\nvar _replaceDefs = _interopRequireDefault(require(\"../svg/replaceDefs\"));\n\nvar _getContainer = _interopRequireDefault(require(\"../svg/getContainer\"));\n\nvar _parseViewbox = _interopRequireDefault(require(\"../svg/parseViewbox\"));\n\nvar _inheritProps = _interopRequireDefault(require(\"../svg/inheritProps\"));\n\nvar _matchPercent = _interopRequireDefault(require(\"../utils/matchPercent\"));\n\nvar _parseAspectRatio = _interopRequireDefault(require(\"../svg/parseAspectRatio\"));\n\nvar STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nvar VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nvar HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nvar isType = R.propEq('type');\nvar isSvg = isType(P.Svg);\nvar isText = isType(P.Text);\nvar isTextInstance = isType(P.TextInstance);\n\nvar transformPercent = function transformPercent(container) {\n  return R.mapObjIndexed(function (value, key) {\n    var match = (0, _matchPercent.default)(value);\n\n    if (match && VERTICAL_PROPS.includes(key)) {\n      return match.percent * container.height;\n    }\n\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n      return match.percent * container.width;\n    }\n\n    return value;\n  });\n};\n\nvar parsePercent = function parsePercent(value) {\n  var match = (0, _matchPercent.default)(value);\n  return match ? match.percent : parseFloat(value);\n};\n\nvar parseProps = function parseProps(container) {\n  return R.compose(R.evolve({\n    props: R.o(R.evolve({\n      x: parseFloat,\n      x1: parseFloat,\n      x2: parseFloat,\n      y: parseFloat,\n      y1: parseFloat,\n      y2: parseFloat,\n      r: parseFloat,\n      rx: parseFloat,\n      ry: parseFloat,\n      cx: parseFloat,\n      cy: parseFloat,\n      width: parseFloat,\n      height: parseFloat,\n      offset: parsePercent,\n      fill: _stylesheet.transformColor,\n      opacity: parsePercent,\n      stroke: _stylesheet.transformColor,\n      stopOpacity: parsePercent,\n      stopColor: _stylesheet.transformColor,\n      transform: _stylesheet.processTransform\n    }), transformPercent(container))\n  }));\n};\n\nvar mergeStyles = function mergeStyles(node) {\n  var style = node.style || {};\n  return R.evolve({\n    props: R.merge(style)\n  }, node);\n};\n\nvar removeNoneValues = R.evolve({\n  props: R.map(R.when(R.equals('none'), R.always(null)))\n});\n\nvar pickStyleProps = function pickStyleProps(node) {\n  var props = node.props || {};\n  var styleProps = R.pick(STYLE_PROPS, props);\n  return R.evolve({\n    style: R.merge(styleProps)\n  }, node);\n};\n\nvar parseSvgProps = R.evolve({\n  props: R.evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: _parseViewbox.default,\n    preserveAspectRatio: _parseAspectRatio.default\n  })\n});\n\nvar wrapBetweenTspan = function wrapBetweenTspan(node) {\n  return {\n    type: P.Tspan,\n    props: {},\n    children: [node]\n  };\n};\n\nvar addMissingTspan = R.when(isText, R.evolve({\n  children: R.map(R.when(isTextInstance, wrapBetweenTspan))\n}));\n\nvar resolveSvgNode = function resolveSvgNode(container) {\n  return R.compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles);\n};\n\nvar resolveChildren = function resolveChildren(container) {\n  return function (node) {\n    return R.evolve({\n      children: R.map(R.compose(resolveChildren(container), resolveSvgNode(container)))\n    })(node);\n  };\n};\n\nvar parseText = function parseText(fontStore) {\n  return function (node) {\n    return R.ifElse(isText, (0, _layoutText.default)(fontStore), R.evolve({\n      children: R.map(parseText(fontStore))\n    }))(node);\n  };\n};\n\nvar resolveSvgRoot = function resolveSvgRoot(fontStore) {\n  return function (node) {\n    var container = (0, _getContainer.default)(node);\n    return R.compose(_replaceDefs.default, parseText(fontStore), parseSvgProps, pickStyleProps, _inheritProps.default, resolveChildren(container))(node);\n  };\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param {Object} root node\n * @param {Object} fontStore font store\n * @returns {Object} root node\n */\n\n\nvar resolveSvg = function resolveSvg(node, fontStore) {\n  var mapChild = function mapChild(child) {\n    return resolveSvg(child, fontStore);\n  };\n\n  return R.compose(R.evolve({\n    children: R.map(mapChild)\n  }), R.when(isSvg, resolveSvgRoot(fontStore)))(node);\n};\n\nvar _default = resolveSvg;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}