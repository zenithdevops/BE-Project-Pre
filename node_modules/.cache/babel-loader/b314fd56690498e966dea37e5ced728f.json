{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _isFixed = _interopRequireDefault(require(\"../node/isFixed\"));\n\nvar _splitText = _interopRequireDefault(require(\"../text/splitText\"));\n\nvar _splitNode2 = _interopRequireDefault(require(\"../node/splitNode\"));\n\nvar _getWrap = _interopRequireDefault(require(\"../node/getWrap\"));\n\nvar _getWrapArea = _interopRequireDefault(require(\"../page/getWrapArea\"));\n\nvar _getContentArea = _interopRequireDefault(require(\"../page/getContentArea\"));\n\nvar _createInstance = _interopRequireDefault(require(\"../node/createInstance\"));\n\nvar _shouldBreak = _interopRequireDefault(require(\"../node/shouldBreak\"));\n\nvar _resolveTextLayout = _interopRequireDefault(require(\"./resolveTextLayout\"));\n\nvar _resolveInheritance = _interopRequireDefault(require(\"./resolveInheritance\"));\n\nvar _resolveDimensions = require(\"./resolveDimensions\");\n/* eslint-disable no-continue */\n\n/* eslint-disable prefer-destructuring */\n\n\nvar isText = R.propEq('type', P.Text); // Prevent splitting elements by low decimal numbers\n\nvar SAFTY_THRESHOLD = 0.001;\nvar assingChildren = R.assoc('children');\nvar getTop = R.pathOr(0, ['box', 'top']);\nvar getHeight = R.path(['box', 'height']);\nvar getChildren = R.propOr([], 'children');\nvar isElementOutside = R.useWith(R.lte, [R.identity, getTop]);\nvar allFixed = R.all(_isFixed.default);\nvar isDynamic = R.hasPath(['props', 'render']);\n\nvar compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    var result = value;\n    var reversedFns = R.reverse(fns);\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    for (var i = 0; i < reversedFns.length; i += 1) {\n      var fn = reversedFns[i];\n      result = fn.apply(void 0, [result].concat(args));\n    }\n\n    return result;\n  };\n};\n\nvar relayoutPage = compose(_resolveTextLayout.default, _resolveInheritance.default, _resolveDimensions.resolvePageDimensions);\n\nvar warnUnavailableSpace = function warnUnavailableSpace(node) {\n  console.warn(\"Node of type \" + node.type + \" can't wrap between pages and it's bigger than available page height\");\n};\n\nvar splitNodes = function splitNodes(height, contentArea, nodes) {\n  var currentChildren = [];\n  var nextChildren = [];\n\n  for (var i = 0; i < nodes.length; i += 1) {\n    var child = nodes[i];\n    var futureNodes = nodes.slice(i + 1);\n    var futureFixedNodes = R.filter(_isFixed.default, futureNodes);\n    var nodeTop = getTop(child);\n    var nodeHeight = getHeight(child);\n    var isOutside = isElementOutside(height, child);\n    var shouldBreak = (0, _shouldBreak.default)(child, futureNodes, height);\n    var shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n    var canWrap = (0, _getWrap.default)(child);\n    var fitsInsidePage = nodeHeight <= contentArea;\n\n    if ((0, _isFixed.default)(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      var next = R.evolve({\n        box: {\n          top: R.subtract(R.__, height)\n        }\n      })(child);\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push.apply(nextChildren, futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n\n    if (shouldBreak) {\n      var _next = R.evolve({\n        box: {\n          top: R.subtract(R.__, height)\n        },\n        props: R.evolve({\n          wrap: R.always(true),\n          break: R.always(false)\n        })\n      })(child);\n\n      currentChildren.push.apply(currentChildren, futureFixedNodes);\n      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));\n      break;\n    }\n\n    if (shouldSplit) {\n      var _split = split(child, height, contentArea),\n          currentChild = _split[0],\n          nextChild = _split[1];\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nvar splitChildren = function splitChildren(height, contentArea, node) {\n  var children = getChildren(node);\n  var availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\n\nvar splitView = function splitView(node, height, contentArea) {\n  var _splitNode = (0, _splitNode2.default)(node, height),\n      currentNode = _splitNode[0],\n      nextNode = _splitNode[1];\n\n  var _splitChildren = splitChildren(height, contentArea, node),\n      currentChilds = _splitChildren[0],\n      nextChildren = _splitChildren[1];\n\n  return [assingChildren(currentChilds)(currentNode), assingChildren(nextChildren)(nextNode)];\n};\n\nvar split = R.ifElse(isText, _splitText.default, splitView);\n\nvar shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {\n  var children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\n\nvar resolveDynamicNodes = function resolveDynamicNodes(props, node) {\n  var isNodeDynamic = isDynamic(node); // Call render prop on dynamic nodes and append result to children\n\n  var resolveChildren = function resolveChildren(children) {\n    if (children === void 0) {\n      children = [];\n    }\n\n    if (isNodeDynamic) {\n      var res = node.props.render(props);\n      return [(0, _createInstance.default)(res)].filter(Boolean);\n    }\n\n    return children.map(function (c) {\n      return resolveDynamicNodes(props, c);\n    });\n  }; // We reset dynamic text box so it can be computed again later on\n\n\n  var resolveBox = function resolveBox(box) {\n    return isNodeDynamic && isText(node) ? (0, _extends2.default)({}, box, {\n      height: 0\n    }) : box;\n  };\n\n  return R.evolve({\n    box: resolveBox,\n    children: resolveChildren,\n    lines: function lines(prev) {\n      return isNodeDynamic ? null : prev;\n    }\n  }, node);\n};\n\nvar resolveDynamicPage = function resolveDynamicPage(props, page, fontStore) {\n  if (shouldResolveDynamicNodes(page)) {\n    var resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore);\n  }\n\n  return page;\n};\n\nvar splitPage = function splitPage(page, pageNumber, fontStore) {\n  var wrapArea = (0, _getWrapArea.default)(page);\n  var contentArea = (0, _getContentArea.default)(page);\n  var height = R.path(['style', 'height'], page);\n  var dynamicPage = resolveDynamicPage({\n    pageNumber: pageNumber\n  }, page, fontStore);\n\n  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children),\n      currentChilds = _splitNodes[0],\n      nextChilds = _splitNodes[1];\n\n  var relayout = function relayout(node) {\n    return relayoutPage(node, fontStore);\n  };\n\n  var currentPage = R.compose(relayout, assingChildren(currentChilds), R.assocPath(['box', 'height'], height))(page);\n  if (R.isEmpty(nextChilds) || allFixed(nextChilds)) return [currentPage, null];\n  var nextPage = R.compose(relayout, assingChildren(nextChilds), R.dissocPath(['box', 'height']))(page);\n  return [currentPage, nextPage];\n};\n\nvar resolvePageIndices = function resolvePageIndices(fontStore) {\n  return function (page, pageNumber, pages) {\n    var totalPages = pages.length;\n    var props = {\n      totalPages: totalPages,\n      pageNumber: pageNumber + 1,\n      subPageNumber: page.subPageNumber + 1,\n      subPageTotalPages: page.subPageTotalPages\n    };\n    return resolveDynamicPage(props, page, fontStore);\n  };\n};\n\nvar assocSubPageData = function assocSubPageData(subpages) {\n  return subpages.map(function (page, i) {\n    return (0, _extends2.default)({}, page, {\n      subPageNumber: i,\n      subPageTotalPages: subpages.length\n    });\n  });\n};\n\nvar dissocSubPageData = function dissocSubPageData(page) {\n  return R.compose(R.dissoc('subPageNumber'), R.dissoc('subPageTotalPages'))(page);\n};\n\nvar paginate = function paginate(page, pageNumber, fontStore) {\n  if (!page) return [];\n  var splittedPage = splitPage(page, pageNumber, fontStore);\n  var pages = [splittedPage[0]];\n  var nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param {Object} node\n * @param {Object} fontStore font store\n * @returns {Object} layout node\n */\n\n\nvar resolvePagination = function resolvePagination(doc, fontStore) {\n  var pages = [];\n  var pageNumber = 1;\n\n  for (var i = 0; i < doc.children.length; i += 1) {\n    var page = doc.children[i];\n    var subpages = paginate(page, pageNumber, fontStore);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(R.compose(dissocSubPageData, resolvePageIndices(fontStore)));\n  return assingChildren(pages, doc);\n};\n\nvar _default = resolvePagination;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}