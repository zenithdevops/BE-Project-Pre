{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _absSvgPath = _interopRequireDefault(require(\"abs-svg-path\"));\n\nvar _parseSvgPath = _interopRequireDefault(require(\"parse-svg-path\"));\n\nvar _normalizeSvgPath = _interopRequireDefault(require(\"normalize-svg-path\"));\n\nvar _isRect = _interopRequireDefault(require(\"../utils/isRect\"));\n\nvar _isLine = _interopRequireDefault(require(\"../utils/isLine\"));\n\nvar _isPath = _interopRequireDefault(require(\"../utils/isPath\"));\n\nvar _isCircle = _interopRequireDefault(require(\"../utils/isCircle\"));\n\nvar _isPolygon = _interopRequireDefault(require(\"../utils/isPolygon\"));\n\nvar _isEllipse = _interopRequireDefault(require(\"../utils/isEllipse\"));\n\nvar _isPolyline = _interopRequireDefault(require(\"../utils/isPolyline\"));\n\nvar _parsePoints = _interopRequireDefault(require(\"./parsePoints\")); // From https://github.com/dy/svg-path-bounds/blob/master/index.js\n\n\nvar getPathBoundingBox = function getPathBoundingBox(node) {\n  var path = R.compose(_normalizeSvgPath.default, _absSvgPath.default, _parseSvgPath.default, R.pathOr('', ['props', 'd']))(node);\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (var i = 0, l = path.length; i < l; i += 1) {\n    var points = path[i].slice(1);\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nvar getCircleBoundingBox = function getCircleBoundingBox(node) {\n  var r = R.pathOr(0, ['props', 'r'], node);\n  var cx = R.pathOr(0, ['props', 'cx'], node);\n  var cy = R.pathOr(0, ['props', 'cy'], node);\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nvar getEllipseBoundingBox = function getEllipseBoundingBox(node) {\n  var cx = R.pathOr(0, ['props', 'cx'], node);\n  var cy = R.pathOr(0, ['props', 'cy'], node);\n  var rx = R.pathOr(0, ['props', 'rx'], node);\n  var ry = R.pathOr(0, ['props', 'ry'], node);\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nvar getLineBoundingBox = function getLineBoundingBox(node) {\n  var x1 = R.pathOr(0, ['props', 'x1'], node);\n  var y1 = R.pathOr(0, ['props', 'y1'], node);\n  var x2 = R.pathOr(0, ['props', 'x2'], node);\n  var y2 = R.pathOr(0, ['props', 'y2'], node);\n  return [R.min(x1, x2), R.min(y1, y2), R.max(x1, x2), R.max(y1, y2)];\n};\n\nvar getRectBoundingBox = function getRectBoundingBox(node) {\n  var x = R.pathOr(0, ['props', 'x'], node);\n  var y = R.pathOr(0, ['props', 'y'], node);\n  var width = R.pathOr(0, ['props', 'width'], node);\n  var height = R.pathOr(0, ['props', 'height'], node);\n  return [x, y, x + width, y + height];\n};\n\nvar max = R.reduce(R.max, -Infinity);\nvar min = R.reduce(R.min, Infinity);\n\nvar getPolylineBoundingBox = function getPolylineBoundingBox(node) {\n  var points = R.compose(_parsePoints.default, R.pathOr([], ['props', 'points']))(node);\n  var xValues = R.pluck(0, points);\n  var yValues = R.pluck(1, points);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nvar getBoundingBox = R.cond([[_isRect.default, getRectBoundingBox], [_isLine.default, getLineBoundingBox], [_isPath.default, getPathBoundingBox], [_isCircle.default, getCircleBoundingBox], [_isEllipse.default, getEllipseBoundingBox], [_isPolygon.default, getPolylineBoundingBox], [_isPolyline.default, getPolylineBoundingBox], [R.T, R.always([0, 0, 0, 0])]]);\nvar _default = getBoundingBox;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}