{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _layoutText = _interopRequireDefault(require(\"../text/layoutText\"));\n/* eslint-disable no-param-reassign */\n\n\nvar isType = R.propEq('type');\nvar isSvg = isType(P.Svg);\nvar isText = isType(P.Text);\nvar isNotSvg = R.complement(isSvg);\nvar isNotText = R.complement(isText);\n\nvar shouldIterate = function shouldIterate(node) {\n  return isNotSvg(node) && isNotText(node);\n};\n\nvar shouldLayoutText = function shouldLayoutText(node) {\n  return isText(node) && !node.lines;\n};\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\n\n\nvar resolveTextLayout = function resolveTextLayout(node, fontStore) {\n  if (shouldLayoutText(node)) {\n    var width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    var height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n    node.lines = (0, _layoutText.default)(node, width, height, fontStore);\n  }\n\n  if (shouldIterate(node)) {\n    var mapChild = function mapChild(child) {\n      return resolveTextLayout(child, fontStore);\n    };\n\n    return R.evolve({\n      children: R.map(mapChild)\n    })(node);\n  }\n\n  return node;\n};\n\nvar _default = resolveTextLayout;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}