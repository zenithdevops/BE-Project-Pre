{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _height = _interopRequireDefault(require(\"@react-pdf/textkit/lib/run/height\"));\n\nvar _descent = _interopRequireDefault(require(\"@react-pdf/textkit/lib/run/descent\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"@react-pdf/textkit/lib/run/advanceWidth\"));\n\nvar _ascent = _interopRequireDefault(require(\"@react-pdf/textkit/lib/attributedString/ascent\"));\n\nvar _renderGlyphs = _interopRequireDefault(require(\"./renderGlyphs\"));\n\nvar _parseColor = _interopRequireDefault(require(\"../utils/parseColor\"));\n/* eslint-disable no-param-reassign */\n\n\nvar DEST_REGEXP = /^#.+/;\n\nvar isSrcId = function isSrcId(src) {\n  return src.match(DEST_REGEXP);\n};\n\nvar renderAttachment = function renderAttachment(ctx, attachment) {\n  var _attachment$xOffset = attachment.xOffset,\n      xOffset = _attachment$xOffset === void 0 ? 0 : _attachment$xOffset,\n      _attachment$yOffset = attachment.yOffset,\n      yOffset = _attachment$yOffset === void 0 ? 0 : _attachment$yOffset,\n      width = attachment.width,\n      height = attachment.height,\n      image = attachment.image;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\n\nvar renderAttachments = function renderAttachments(ctx, run) {\n  ctx.save();\n  var font = run.attributes.font;\n  var space = font.glyphForCodePoint(0x20);\n  var objectReplacement = font.glyphForCodePoint(0xfffc);\n  var attachmentAdvance = 0;\n\n  for (var i = 0; i < run.glyphs.length; i += 1) {\n    var position = run.positions[i];\n    var glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n\n  ctx.restore();\n};\n\nvar renderRun = function renderRun(ctx, run, options) {\n  var _run$attributes = run.attributes,\n      font = _run$attributes.font,\n      fontSize = _run$attributes.fontSize,\n      link = _run$attributes.link;\n  var color = (0, _parseColor.default)(run.attributes.color);\n  var opacity = R.defaultTo(color.opacity, run.attributes.opacity);\n  var height = (0, _height.default)(run);\n  var descent = (0, _descent.default)(run);\n  var runAdvanceWidth = (0, _advanceWidth.default)(run);\n\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, runAdvanceWidth, height).stroke();\n  }\n\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n\n  if (link) {\n    if (isSrcId(link)) {\n      ctx.goTo(0, -height - descent, runAdvanceWidth, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, runAdvanceWidth, height, link);\n    }\n  }\n\n  renderAttachments(ctx, run);\n\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (var i = 0; i < run.glyphs.length; i += 1) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      (0, _renderGlyphs.default)(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nvar renderBackground = function renderBackground(ctx, rect, backgroundColor) {\n  var color = (0, _parseColor.default)(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\n\nvar renderDecorationLine = function renderDecorationLine(ctx, line) {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n\n  if (/wavy/.test(line.style)) {\n    var dist = Math.max(2, line.rect.height);\n    var step = 1.1 * dist;\n    var stepCount = Math.floor(line.rect.width / (2 * step)); // Adjust step to fill entire width\n\n    var remainingWidth = line.rect.width - stepCount * 2 * step;\n    var adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    var cp1y = line.rect.y + dist;\n    var cp2y = line.rect.y - dist;\n    var x = line.rect.x;\n    ctx.moveTo(line.rect.x, line.rect.y);\n\n    for (var i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n\n  ctx.stroke(line.color);\n  ctx.restore();\n};\n\nvar renderLine = function renderLine(ctx, line, options) {\n  var lineAscent = (0, _ascent.default)(line);\n\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n\n  for (var i = 0; i < line.runs.length; i += 1) {\n    var run = line.runs[i];\n    var isLastRun = i === line.runs.length - 1;\n\n    if (run.attributes.backgroundColor) {\n      var overflowRight = isLastRun ? line.overflowRight : 0;\n      var backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: (0, _advanceWidth.default)(run) - overflowRight\n      };\n      renderBackground(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n\n    renderRun(ctx, run, options);\n  }\n\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n\n  for (var _i = 0; _i < line.decorationLines.length; _i += 1) {\n    var decorationLine = line.decorationLines[_i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n\n  ctx.restore();\n};\n\nvar renderBlock = function renderBlock(ctx, block, options) {\n  block.forEach(function (line) {\n    renderLine(ctx, line, options);\n  });\n};\n\nvar renderText = function renderText(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left;\n  var blocks = [node.lines];\n  var paddingTop = R.pathOr(0, ['box', 'paddingTop'], node);\n  var paddingLeft = R.pathOr(0, ['box', 'paddingLeft'], node);\n  var initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  var offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(function (block) {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n  return node;\n};\n\nvar _default = R.curryN(2, renderText);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}