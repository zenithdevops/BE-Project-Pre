{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"@react-pdf/textkit/lib/run/advanceWidth\"));\n\nvar _advanceWidth2 = _interopRequireDefault(require(\"@react-pdf/textkit/lib/attributedString/advanceWidth\"));\n\nvar _renderGlyphs = _interopRequireDefault(require(\"./renderGlyphs\"));\n\nvar renderRun = function renderRun(ctx, run) {\n  var runAdvanceWidth = (0, _advanceWidth.default)(run);\n  var _run$attributes = run.attributes,\n      font = _run$attributes.font,\n      fontSize = _run$attributes.fontSize,\n      color = _run$attributes.color,\n      opacity = _run$attributes.opacity;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (var i = 0; i < run.glyphs.length; i += 1) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      (0, _renderGlyphs.default)(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nvar renderSpan = function renderSpan(ctx, line, textAnchor, dominantBaseline) {\n  ctx.save();\n  var x = R.pathOr(0, ['box', 'x'], line);\n  var y = R.pathOr(0, ['box', 'y'], line);\n  var font = R.pathOr(1, ['runs', 0, 'attributes', 'font'], line);\n  var scale = R.pathOr(1, ['runs', 0, 'attributes', 'scale'], line);\n  var width = (0, _advanceWidth2.default)(line);\n  var ascent = font.ascent * scale;\n  var xHeight = font.xHeight * scale;\n  var descent = font.descent * scale;\n  var capHeight = font.capHeight * scale;\n  var xTranslate = x;\n  var yTranslate = y;\n\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n\n    case 'end':\n      xTranslate = x - width;\n      break;\n\n    default:\n      xTranslate = x;\n      break;\n  }\n\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n\n    default:\n      yTranslate = y;\n      break;\n  }\n\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(function (run) {\n    return renderRun(ctx, run);\n  });\n  ctx.restore();\n};\n\nvar renderSvgText = function renderSvgText(ctx) {\n  return function (node) {\n    node.children.forEach(function (span) {\n      return renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline);\n    });\n    return node;\n  };\n};\n\nvar _default = renderSvgText;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}