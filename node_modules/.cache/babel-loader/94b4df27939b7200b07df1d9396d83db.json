{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _renderPath = _interopRequireDefault(require(\"./renderPath\"));\n\nvar _renderRect = _interopRequireDefault(require(\"./renderRect\"));\n\nvar _renderLine = _interopRequireDefault(require(\"./renderLine\"));\n\nvar _renderGroup = _interopRequireDefault(require(\"./renderGroup\"));\n\nvar _renderCircle = _interopRequireDefault(require(\"./renderCircle\"));\n\nvar _renderSvgText = _interopRequireDefault(require(\"./renderSvgText\"));\n\nvar _renderEllipse = _interopRequireDefault(require(\"./renderEllipse\"));\n\nvar _renderPolygon = _interopRequireDefault(require(\"./renderPolygon\"));\n\nvar _renderPolyline = _interopRequireDefault(require(\"./renderPolyline\"));\n\nvar _renderSvgImage = _interopRequireDefault(require(\"./renderSvgImage\"));\n\nvar _isPath = _interopRequireDefault(require(\"../utils/isPath\"));\n\nvar _isText = _interopRequireDefault(require(\"../utils/isText\"));\n\nvar _isRect = _interopRequireDefault(require(\"../utils/isRect\"));\n\nvar _isLine = _interopRequireDefault(require(\"../utils/isLine\"));\n\nvar _isTspan = _interopRequireDefault(require(\"../utils/isTspan\"));\n\nvar _isImage = _interopRequireDefault(require(\"../utils/isImage\"));\n\nvar _isGroup = _interopRequireDefault(require(\"../utils/isGroup\"));\n\nvar _isCircle = _interopRequireDefault(require(\"../utils/isCircle\"));\n\nvar _isEllipse = _interopRequireDefault(require(\"../utils/isEllipse\"));\n\nvar _isPolygon = _interopRequireDefault(require(\"../utils/isPolygon\"));\n\nvar _isPolyline = _interopRequireDefault(require(\"../utils/isPolyline\"));\n\nvar _isTextInstance = _interopRequireDefault(require(\"../utils/isTextInstance\"));\n\nvar _save = _interopRequireDefault(require(\"../operations/save\"));\n\nvar _restore = _interopRequireDefault(require(\"../operations/restore\"));\n\nvar _clipNode = _interopRequireDefault(require(\"../operations/clipNode\"));\n\nvar _transform = _interopRequireDefault(require(\"../operations/transform\"));\n\nvar _getBoundingBox = _interopRequireDefault(require(\"../svg/getBoundingBox\"));\n\nvar warnUnsupportedNode = R.tap(function (node) {\n  console.warn(\"SVG node of type \" + node.type + \" is not currenty supported\");\n});\n\nvar getProp = function getProp(d, p, v) {\n  return R.pathOr(d, ['props', p], v);\n};\n\nvar setStrokeWidth = function setStrokeWidth(ctx) {\n  return function (node) {\n    var lineWidth = getProp(0, 'strokeWidth', node);\n    if (lineWidth) ctx.lineWidth(lineWidth);\n    return node;\n  };\n};\n\nvar setStrokeColor = function setStrokeColor(ctx) {\n  return function (node) {\n    var strokeColor = getProp(null, 'stroke', node);\n    if (strokeColor) ctx.strokeColor(strokeColor);\n    return node;\n  };\n};\n\nvar setOpacity = function setOpacity(ctx) {\n  return function (node) {\n    var opacity = getProp(null, 'opacity', node);\n    if (!R.isNil(opacity)) ctx.opacity(opacity);\n    return node;\n  };\n};\n\nvar setFillOpacity = function setFillOpacity(ctx) {\n  return function (node) {\n    var fillOpacity = getProp(null, 'fillOpacity', node);\n    if (!R.isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n    return node;\n  };\n};\n\nvar setStrokeOpacity = function setStrokeOpacity(ctx) {\n  return function (node) {\n    var strokeOpacity = getProp(null, 'strokeOpacity', node);\n    if (!R.isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n    return node;\n  };\n};\n\nvar setLineJoin = function setLineJoin(ctx) {\n  return function (node) {\n    var lineJoin = getProp(null, 'strokeLinejoin', node);\n    if (lineJoin) ctx.lineJoin(lineJoin);\n    return node;\n  };\n};\n\nvar setLineCap = function setLineCap(ctx) {\n  return function (node) {\n    var lineCap = getProp(null, 'strokeLinecap', node);\n    if (lineCap) ctx.lineCap(lineCap);\n    return node;\n  };\n};\n\nvar setLineDash = function setLineDash(ctx) {\n  return function (node) {\n    var value = getProp(null, 'strokeDasharray', node);\n    if (value) ctx.dash(R.split(',', value));\n    return node;\n  };\n};\n\nvar hasLinearGradientFill = R.pathEq(['props', 'fill', 'type'], P.LinearGradient);\nvar hasRadialGradientFill = R.pathEq(['props', 'fill', 'type'], P.RadialGradient); // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\n\nvar setLinearGradientFill = function setLinearGradientFill(ctx) {\n  return R.tap(function (node) {\n    var bbox = (0, _getBoundingBox.default)(node);\n    var gradient = getProp(null, 'fill', node);\n    var x1 = R.pathOr(0, ['props', 'x1'], gradient);\n    var y1 = R.pathOr(0, ['props', 'y1'], gradient);\n    var x2 = R.pathOr(1, ['props', 'x2'], gradient);\n    var y2 = R.pathOr(0, ['props', 'y2'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gx1 = m0 * x1 + m4;\n    var gy1 = m3 * y1 + m5;\n    var gx2 = m0 * x2 + m4;\n    var gy2 = m3 * y2 + m5;\n    var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\n\n\nvar setRadialGradientFill = function setRadialGradientFill(ctx) {\n  return R.tap(function (node) {\n    var bbox = (0, _getBoundingBox.default)(node);\n    var gradient = getProp(null, 'fill', node);\n    var cx = R.pathOr(0.5, ['props', 'cx'], gradient);\n    var cy = R.pathOr(0.5, ['props', 'cy'], gradient);\n    var fx = R.pathOr(cx, ['props', 'fx'], gradient);\n    var fy = R.pathOr(cy, ['props', 'fy'], gradient);\n    var r = R.pathOr(0.5, ['props', 'r'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gr = r * m0;\n    var gcx = m0 * cx + m4;\n    var gcy = m3 * cy + m5;\n    var gfx = m0 * fx + m4;\n    var gfy = m3 * fy + m5;\n    var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n};\n\nvar setFillColor = function setFillColor(ctx) {\n  return R.tap(function (node) {\n    var fillColor = getProp(null, 'fill', node);\n    if (fillColor) ctx.fillColor(fillColor);\n  });\n};\n\nvar setFill = function setFill(ctx) {\n  return R.cond([[hasLinearGradientFill, setLinearGradientFill(ctx)], [hasRadialGradientFill, setRadialGradientFill(ctx)], [R.T, setFillColor(ctx)]]);\n};\n\nvar draw = function draw(ctx) {\n  return function (node) {\n    var props = R.propOr({}, 'props', node);\n\n    if (props.fill && props.stroke) {\n      ctx.fillAndStroke(props.fillRule);\n    } else if (props.fill) {\n      ctx.fill(props.fillRule);\n    } else if (props.stroke) {\n      ctx.stroke();\n    } else {\n      ctx.save();\n      ctx.opacity(0);\n      ctx.fill(null);\n      ctx.restore();\n    }\n\n    return node;\n  };\n};\n\nvar renderNode = function renderNode(ctx) {\n  return R.cond([[_isTspan.default, R.identity], [_isTextInstance.default, R.identity], [_isPath.default, (0, _renderPath.default)(ctx)], [_isRect.default, (0, _renderRect.default)(ctx)], [_isLine.default, (0, _renderLine.default)(ctx)], [_isGroup.default, (0, _renderGroup.default)(ctx)], [_isText.default, (0, _renderSvgText.default)(ctx)], [_isCircle.default, (0, _renderCircle.default)(ctx)], [_isImage.default, (0, _renderSvgImage.default)(ctx)], [_isEllipse.default, (0, _renderEllipse.default)(ctx)], [_isPolygon.default, (0, _renderPolygon.default)(ctx)], [_isPolyline.default, (0, _renderPolyline.default)(ctx)], [R.T, warnUnsupportedNode]]);\n};\n\nvar drawNode = function drawNode(ctx) {\n  return R.compose(draw(ctx), renderNode(ctx), (0, _transform.default)(ctx), setOpacity(ctx), setFillOpacity(ctx), setStrokeOpacity(ctx), setFill(ctx), setStrokeColor(ctx), setStrokeWidth(ctx), setLineJoin(ctx), setLineDash(ctx), setLineCap(ctx));\n};\n\nvar clipPath = function clipPath(ctx) {\n  return function (node) {\n    var value = R.path(['props', 'clipPath'], node);\n\n    if (value) {\n      R.compose(function () {\n        return ctx.clip();\n      }, R.forEach(renderNode(ctx)), R.propOr([], 'children'))(value);\n    }\n\n    return node;\n  };\n};\n\nvar drawChildren = function drawChildren(ctx) {\n  return function (node) {\n    return R.compose(R.map(R.compose((0, _restore.default)(ctx), drawChildren(ctx), drawNode(ctx), clipPath(ctx), (0, _save.default)(ctx))), R.propOr([], 'children'))(node);\n  };\n};\n\nvar defaultsZero = R.pathOr(0);\n\nvar resolveAspectRatio = function resolveAspectRatio(ctx) {\n  return function (node) {\n    var _node$box = node.box,\n        width = _node$box.width,\n        height = _node$box.height;\n    var _node$props = node.props,\n        viewBox = _node$props.viewBox,\n        _node$props$preserveA = _node$props.preserveAspectRatio,\n        preserveAspectRatio = _node$props$preserveA === void 0 ? {} : _node$props$preserveA;\n    var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice,\n        meetOrSlice = _preserveAspectRatio$ === void 0 ? 'meet' : _preserveAspectRatio$,\n        _preserveAspectRatio$2 = preserveAspectRatio.align,\n        align = _preserveAspectRatio$2 === void 0 ? 'xMidYMid' : _preserveAspectRatio$2;\n    if (viewBox == null || width == null || height == null) return node;\n    var x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n    var y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n    var logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n    var logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n    var logicalRatio = logicalWidth / logicalHeight;\n    var physicalRatio = width / height;\n    var scaleX = width / logicalWidth;\n    var scaleY = height / logicalHeight;\n\n    if (align === 'none') {\n      ctx.scale(scaleX, scaleY);\n      ctx.translate(-x, -y);\n      return node;\n    }\n\n    if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n      ctx.scale(scaleY, scaleY);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMinYMid':\n        case 'xMinYMax':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMidYMin':\n        case 'xMidYMid':\n        case 'xMidYMax':\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n          break;\n\n        default:\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n      }\n    } else {\n      ctx.scale(scaleX, scaleX);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMidYMin':\n        case 'xMaxYMin':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMinYMid':\n        case 'xMidYMid':\n        case 'xMaxYMid':\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n          break;\n\n        default:\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n      }\n    }\n\n    return node;\n  };\n};\n\nvar moveToOrigin = function moveToOrigin(ctx) {\n  return function (node) {\n    var _node$box2 = node.box,\n        top = _node$box2.top,\n        left = _node$box2.left;\n    var paddingLeft = defaultsZero('paddingLeft', node.box);\n    var paddingTop = defaultsZero('paddingTop', node.box);\n    ctx.translate(left + paddingLeft, top + paddingTop);\n    return node;\n  };\n};\n\nvar renderSvg = function renderSvg(ctx, node) {\n  R.compose((0, _restore.default)(ctx), drawChildren(ctx), resolveAspectRatio(ctx), moveToOrigin(ctx), (0, _clipNode.default)(ctx), (0, _save.default)(ctx))(node);\n  return node;\n};\n\nvar _default = R.curryN(2, renderSvg);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}