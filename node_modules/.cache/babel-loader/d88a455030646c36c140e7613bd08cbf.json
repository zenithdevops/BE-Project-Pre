{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // TODO: Implement using only matrices to support skew and even more operations than css.\n\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}