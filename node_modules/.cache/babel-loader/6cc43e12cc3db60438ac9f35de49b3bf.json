{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _attributedString = _interopRequireDefault(require(\"@react-pdf/textkit/lib/attributedString\"));\n\nvar _emoji = require(\"./emoji\");\n\nvar _ignoreChars = _interopRequireDefault(require(\"./ignoreChars\"));\n\nvar _transformText = _interopRequireDefault(require(\"./transformText\"));\n\nvar PREPROCESSORS = [_ignoreChars.default, _emoji.embedEmojis];\nvar isType = R.propEq('type');\nvar isImage = isType(P.Image);\nvar isTextInstance = isType(P.TextInstance);\n/**\n * Get textkit fragments of given node object\n *\n * @param {Object} font store\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\n\nvar getFragments = function getFragments(fontStore, instance, parentLink, level) {\n  var _instance$props, _instance$props2;\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n      _instance$style$color = _instance$style.color,\n      color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n      _instance$style$fontF = _instance$style.fontFamily,\n      fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n      fontWeight = _instance$style.fontWeight,\n      fontStyle = _instance$style.fontStyle,\n      _instance$style$fontS = _instance$style.fontSize,\n      fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n      _instance$style$textA = _instance$style.textAlign,\n      textAlign = _instance$style$textA === void 0 ? 'left' : _instance$style$textA,\n      lineHeight = _instance$style.lineHeight,\n      textDecoration = _instance$style.textDecoration,\n      textDecorationColor = _instance$style.textDecorationColor,\n      textDecorationStyle = _instance$style.textDecorationStyle,\n      textTransform = _instance$style.textTransform,\n      letterSpacing = _instance$style.letterSpacing,\n      textIndent = _instance$style.textIndent,\n      opacity = _instance$style.opacity;\n  var opts = {\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  };\n  var obj = fontStore ? fontStore.getFont(opts) : null;\n  var font = obj ? obj.data : fontFamily; // Don't pass main background color to textkit. Will be rendered by the render package instead\n\n  var backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    backgroundColor: backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n\n  for (var i = 0; i < instance.children.length; i += 1) {\n    var child = instance.children[i];\n\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: (0, _extends2.default)({}, attributes, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: (0, _transformText.default)(child.value, textTransform),\n        attributes: attributes\n      });\n    } else if (child) {\n      var _fragments;\n\n      (_fragments = fragments).push.apply(_fragments, getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n\n  for (var _i = 0; _i < PREPROCESSORS.length; _i += 1) {\n    var preprocessor = PREPROCESSORS[_i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} font store\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\n\n\nvar getAttributedString = function getAttributedString(fontStore, instance) {\n  var fragments = getFragments(fontStore, instance);\n  return _attributedString.default.fromFragments(fragments);\n};\n\nvar _default = R.curryN(2, getAttributedString);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}