{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\n\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\n\nvar fetch = require('cross-fetch');\n\nvar PNG = require('@react-pdf/png-js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\n\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\n\nvar fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);\n\nvar PNG__default = /*#__PURE__*/_interopDefaultLegacy(PNG);\n\nPNG__default[\"default\"].isValid = function (data) {\n  try {\n    return !!new PNG__default[\"default\"](data);\n  } catch (e) {\n    return false;\n  }\n}; // Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\n\nvar JPEG = function JPEG(data) {\n  this.data = null;\n  this.width = null;\n  this.height = null;\n  this.data = data;\n\n  if (data.readUInt16BE(0) !== 0xffd8) {\n    throw new Error('SOI not found in JPEG');\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    throw new Error('Invalid JPEG.');\n  }\n\n  pos += 3;\n  this.height = data.readUInt16BE(pos);\n  pos += 2;\n  this.width = data.readUInt16BE(pos);\n};\n\nJPEG.isValid = function (data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar createCache = function createCache(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? 100 : _ref$limit;\n\n  var cache = {};\n  var keys = [];\n  return {\n    get: function get(key) {\n      return cache[key];\n    },\n    set: function set(key, value) {\n      keys.push(key);\n\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n\n      cache[key] = value;\n    },\n    reset: function reset() {\n      cache = {};\n      keys = [];\n    },\n    length: function length() {\n      return keys.length;\n    }\n  };\n};\n\nvar IMAGE_CACHE = createCache({\n  limit: 30\n});\n\nvar fetchRemoteFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee(uri, options) {\n    var response, buffer;\n    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch__default[\"default\"](uri, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchRemoteFile(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isValidFormat = function isValidFormat(format) {\n  var lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nvar guessFormat = function guessFormat(buffer) {\n  var format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG__default[\"default\"].isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nvar isCompatibleBase64 = function isCompatibleBase64(_ref2) {\n  var uri = _ref2.uri;\n  return /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n};\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n\n    case 'png':\n      return new PNG__default[\"default\"](body);\n\n    default:\n      return null;\n  }\n}\n\nvar resolveBase64Image = function resolveBase64Image(_ref3) {\n  var uri = _ref3.uri;\n  var match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  var format = match[1];\n  var data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(\"Base64 image invalid format: \" + format);\n  }\n\n  return new Promise(function (resolve) {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nvar resolveImageFromData = function resolveImageFromData(src) {\n  if (src.data && src.format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(src.data, src.format));\n    });\n  }\n\n  throw new Error(\"Invalid data given for local file: \" + JSON.stringify(src));\n};\n\nvar resolveBufferImage = function resolveBufferImage(buffer) {\n  var format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(buffer, format));\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar getImageFormat = function getImageFormat(body) {\n  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;\n  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n  var extension = '';\n\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nvar resolveImageFromUrl = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee2(src) {\n    var uri, body, headers, _src$method, method, data, extension;\n\n    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? 'GET' : _src$method;\n            {\n              _context2.next = 7;\n              break;\n            }\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.next = 9;\n            return fetchRemoteFile(uri, {\n              body: body,\n              headers: headers,\n              method: method\n            });\n\n          case 9:\n            _context2.t0 = _context2.sent;\n\n          case 10:\n            data = _context2.t0;\n            extension = getImageFormat(data);\n            return _context2.abrupt(\"return\", getImage(data, extension));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveImageFromUrl(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar resolveImage = function resolveImage(src, _temp) {\n  var _ref5 = _temp === void 0 ? {} : _temp,\n      _ref5$cache = _ref5.cache,\n      cache = _ref5$cache === void 0 ? true : _ref5$cache;\n\n  var cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  var image;\n\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexports[\"default\"] = resolveImage;","map":null,"metadata":{},"sourceType":"script"}